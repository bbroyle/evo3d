# ALIGN UTILS ----
#' Calculate Aligned Coverage Ranges
#'
#' Identifies contiguous non-gap regions in a sequence alignment matrix and formats as range strings.
#'
#' @param aln_mat Character matrix from alignment with rows as sequences and columns as positions.
#' @param mismatch Optional numeric vector of mismatch positions between sequences.
#'
#' @return A named list of character vectors, each representing ranges (e.g., "5:25") for each sequence.
#' @export
.calculate_coverage = function(aln_mat, mismatch) {
  covered_regions = list()
  
  # convert alignments into ranges
  for (i in 1:nrow(aln_mat)) {
    seq_name = rownames(aln_mat)[i]
    # ignore gap positions
    positions = which(aln_mat[i, ] != "-")
    
    if (length(positions) > 0) {
      # find breaks in sequence
      breaks = c(0, which(diff(positions) > 1), length(positions))
      ranges = character()
      
      for (j in 1:(length(breaks) - 1)) {
        start_idx = breaks[j] + 1
        end_idx = breaks[j + 1]
        start_pos = positions[start_idx]
        end_pos = positions[end_idx]
        ranges = c(ranges, paste0(start_pos, ":", end_pos))
      }
      
      covered_regions[[seq_name]] = ranges
    } else {
      covered_regions[[seq_name]] = character(0)
    }
  }
  
  # convert mismatches into ranges
  if (length(mismatch) > 0) {
    # find breaks in sequence
    breaks = c(0, which(diff(mismatch) > 1), length(mismatch))
    ranges = character()
    
    for (j in 1:(length(breaks) - 1)) {
      start_idx = breaks[j] + 1
      end_idx = breaks[j + 1]
      start_pos = mismatch[start_idx]
      end_pos = mismatch[end_idx]
      ranges = c(ranges, paste0(start_pos, ":", end_pos))
    }
    
    covered_regions$mismatch = ranges
  } else {
    covered_regions$mismatch = NA
  }
  
  
  return(covered_regions)
}


#' Plot Sequence Alignment Coverage
#'
#' Visualizes alignment coverage as horizontal bars for each sequence.
#'
#' @param coverage A coverage list generated by \code{calculate_coverage()}.
#'
#' @return A \code{ggplot2} object.
#' @export
.plot_coverage = function(coverage) {
  # convert coverage to data frame for plotting
  plot_data <- data.frame(
    sequence = character(),
    start = numeric(),
    end = numeric(),
    stringsAsFactors = FALSE
  )
  
  # see if mismatch has ranges or if it is NA #
  if(is.na(coverage$mismatch[1])){
    coverage$mismatch = '0:0'
  }
  
  for (seq_name in names(coverage)) {
    ranges <- coverage[[seq_name]]
    for (range in ranges) {
      range_parts <- as.numeric(strsplit(range, ":")[[1]])
      plot_data <- rbind(plot_data, data.frame(
        sequence = seq_name,
        start = range_parts[1],
        end = range_parts[2],
        stringsAsFactors = FALSE
      ))
    }
  }
  
  # shrink name if too long (max 20 char then ...) #
  plot_data$sequence = apply(plot_data, 1, function(x) {
    if (nchar(x[1]) > 20) {
      return(paste0(substr(x[1], 1, 20), " ..."))
    } else {
      return(x[1])
    }
  })
  
  plot_data$sequence = factor(plot_data$sequence, levels = unique(plot_data$sequence))
  
  # *** STILL NEED TO INCORPORATE MISMATCH POINTS *** #
  plot <- ggplot2::ggplot(plot_data, ggplot2::aes(x = start, xend = end, y = sequence, yend = sequence)) +
    ggplot2::geom_segment(linewidth = 3) +
    ggplot2::theme_bw() +
    ggplot2::xlab("Alignment Position") +
    ggplot2::ylab("Sequence")
  
  return(plot)
  
}



#' Align Reference and PDB Sequences
#'
#' Aligns two protein sequences using ClustalOmega and calculates positional mismatches and coverage.
#'
#' @param sequences A named character vector of two sequences (reference first).
#' @param generate_plot Logical, whether to return a coverage plot.
#' @param user_supplied_alignment Optional pre-aligned sequences (currently not used).
#'
#' @return A list with the alignment matrix, coverage info, and optional coverage plot.
#' @export
align_sequences = function(sequences, generate_plot = T, user_supplied_alignment = NULL){
  # need to track original gap (from msa)
  # then introduced gaps (from alignment)
  # also track matching positions

  # use msa::msa() ~ with baked in clustal omega (defualt to GONNET sub matrix)
  aln = msa::msa(sequences, method = 'ClustalOmega', type = 'protein', order = 'input')
  
  aln_set = as.character(aln@unmasked)
  aln_chars = strsplit(aln_set, '')
  
  # which position are identical
  mismatch = which(aln_chars[[1]] != aln_chars[[2]])
  
  # only keep mismatch if they are aa to aa (not - or X)
  mismatch = mismatch[!aln_chars[[1]][mismatch] %in% c('-', 'X')]
  mismatch = mismatch[!aln_chars[[2]][mismatch] %in% c('-')]
  
  # unpack alignment into matrix
  aln_mat = do.call(rbind, aln_chars)
  rownames(aln_mat) = names(sequences)
  
  # calculate coverage and plot #
  coverage = .calculate_coverage(aln_mat, mismatch)
  
  if(generate_plot){
    coverage_plot = .plot_coverage(coverage)
  } else {
    coverage_plot = NULL
  }
  
  # return alignment matrix and coverage plot
  return(list(
    aln_mat = aln_mat, 
    coverage = coverage,
    coverage_plot = coverage_plot
  ))
}



#' Map Aligned Amino Acid Positions to Nucleotide Positions
#'
#' Maps PDB residues and codons to alignment columns for downstream patch-to-nucleotide mapping.
#'
#' @param aln_mat Alignment matrix from \code{align_sequences()}.
#' @param patches A residue-level data frame from \code{identify_patches()} or \code{WRAPPER_pdb_to_patch()}.
#' @param chain Optional chain ID for filtering.
#'
#' @return An updated alignment matrix with a nucleotide position row.
#' @export
map_aln_to_positions = function(aln_mat, patches, chain = NULL){
  # msa is fasta object read in with bio3d::read.fasta()
  # aln_mat is from align_sequences() aln_mat$aln_mat
  # patches is from identify_windows()
  
  # filter for chain of interest #
  if(!is.null(chain)){
    patches = patches[patches$orig_chain %in% chain,]
  }
  
  # replace aa residues with position #
  # assuming first is ref sequence #
  ref_pos = which(aln_mat[1,]!='-')
  aln_mat[1,ref_pos] = 1:length(ref_pos)
  
  # for each set in patches update that row+1 in aln_mat
  pos = patches$residue_id
  
  # drop any position that start with epi # 
  pos = pos[!grepl('epi', pos)]
  
  # fill position in pdb seq with position #
  ref_pos = which(aln_mat[2,]!='-')
  aln_mat[2,ref_pos] = pos
  
  
  # add one more row for nuc positions
  aln_mat = rbind(aln_mat, aln_mat[1,])
  rownames(aln_mat)[nrow(aln_mat)] = 'nucleotide'
  
  # convert to codon positions #
  count = 1
  for(i in 1:ncol(aln_mat)){
    if(aln_mat[nrow(aln_mat),i] != '-'){ 
      end = count * 3
      start = end - 2
      aln_mat[nrow(aln_mat),i] = paste0(start, ':', end)
      count = count + 1
    }
  }
  
  return(aln_mat)
}



#' Convert Protein Patch Regions to Nucleotide Coordinates
#'
#' Maps residue patch identifiers to codon-level nucleotide positions based on alignment matrix.
#'
#' @param pos_aln Alignment matrix with codon mapping row (from \code{map_aln_to_positions()}).
#' @param patches Patch dataframe with \code{residue_id} and \code{patch} columns.
#'
#' @return Data frame with added \code{nuc} and \code{codon} columns for each patch.
#' @export
map_patches_to_nucleotides = function(pos_aln, patches){
  # only works on one msa #
  # pull all positions from this MSA #
  
  # convert patch postions to nuc positions #
  df = patches['residue_id']
  df$nuc = ''
  df$codon = ''
  
  for(i in 1:nrow(patches)){
    
    # if no patch -- skip
    patch = patches$patch[i]
    if(is.na(patch)){
      next
    }
    
    # what codon positions do these come from #
    # positions on other chains will not be included #
    patch = unlist(strsplit(patch, '\\+'))
    codons = which(pos_aln[2,] %in% patch)
    
    # if no codon positions -- skip {all positions on other chains}
    if(length(codons) == 0){
      next
    }
    
    # build nucleotide positions #
    nuc = pos_aln['nucleotide', codons]
    
    # if there is no codon beneath this patch -- remove from set #
    nuc = nuc[nuc != '-']
    
    df$nuc[i] = paste0(nuc, collapse = '+')
    
    # if central residue of patch comes from this msa set #
    # record codon number in df #
    if(df$residue_id[i] %in% pos_aln[2,]){
      df$codon[i] = pos_aln[1, which(pos_aln[2,] == df$residue_id[i])]
    }
  }
  
  # ** some have windows but central residue is not in msa ** (4/22) - I would like to set their windows to NA but
  # other option is just leave them (central residue doesn't have match but window still touches other regions)
  
  df$nuc[df$codon=='-'] = ''
  #df$codon[df$codon=='-'] = ''
  
  # every residue is present -- nuc window provided for those positions that map to msa -- 
  # codon column shows codon pos (if - there is no position in msa, but aa met capture window centroid criteria)
  
  return(df)
}



#' Extract Nucleotide MSA Windows
#'
#' Subsets nucleotide MSA regions corresponding to patch windows mapped from protein structure.
#'
#' @param msa A nucleotide multiple sequence alignment matrix.
#' @param nuc_patches A data frame with nucleotide windows for each residue patch.
#'
#' @return A named list of MSA subset matrices, one per patch.
#' @export
extract_msa_subsets = function(msa, nuc_patches){
  # msa is the alignment matrix #
  # nuc_patches is the patches to extract #
  
  # drop patches that dont have nuc positions #
  patches = nuc_patches[nuc_patches$nuc != '',]
  
  msa_subset = list()
  for(i in 1:nrow(patches)){
    nucs = patches$nuc[i]
    pos = unlist(strsplit(nucs, '\\+'))
    
    # expand pos set #
    pos = unlist(lapply(pos, function(x){
      eval(parse(text = x))
    }))
    
    # subset #
    fasta = msa[,pos]
    msa_subset[[i]] = fasta
    names(msa_subset)[i] = patches$residue_id[i]
  }
  
  # return list of subsets #
  return(msa_subset)
}



#' Align MSA to PDB and Extract Nucleotide Windows
#'
#' High-level wrapper to align a reference sequence and structure, map patches to codons, and extract MSA subsets.
#'
#' @param msa_info Output list from \code{WRAPPER_msa_to_ref()}.
#' @param pdb_info Output list from \code{WRAPPER_pdb_to_patch()}.
#' @param coverage_plot Logical, show alignment coverage plot.
#' @param chain Optional chain ID to restrict analysis.
#'
#' @return A list with alignment matrix, position matrix, nucleotide patches, and MSA subsets.
#' @export
WRAPPER_align_msa_pdb = function(msa_info, pdb_info, coverage_plot = F, chain = NULL){
  
  # msa_info ~ must be list object from WRAPPER_msa #
  # pdb_info ~ must be list object from WRAPPER_pdb #
  
  # step 0: prep data #
  pep = msa_info$pep
  seq = pdb_info$seq_set
  
  # if chain is not null -- filter for that chain #
  if(!is.null(chain)){
    seq = seq[chain]
  }
  
  residue_df = pdb_info$residue_df
  
  # step 1: align sequences #
  aln = align_sequences(c(pep, seq), generate_plot = coverage_plot)
  
  # step 2: map alignment to positions #
  pos_mat = map_aln_to_positions(aln$aln_mat, 
                                 residue_df, 
                                 chain = chain)
  
  # step 3: map patches to nucleotides #
  nuc_patches = map_patches_to_nucleotides(pos_mat, residue_df)
  
  # step 4: grab subsets of MSA #
  msa_subsets = extract_msa_subsets(msa_info$msa_mat, nuc_patches)
  
  # return data #
  return(list(
    aln_mat = aln, 
    pos_mat = pos_mat, 
    nuc_patches = nuc_patches,
    msa_subsets = msa_subsets)
  )
  
}